#' Phase_type
#'
#' Description of the S3 classes \code{cont_phase_type}, \code{disc_phase_type},
#' \code{mult_cont_phase_type}, \code{mult_disc_phase_type} which represents the
#' different phase-type distributions.
#'
#' @details
#'
#' \code{phase_type} is the generator function for the four types of phase-type
#' classes, respectively univariate continuous or discrete and multivariate
#' continuous or discrete which inherits from \code{list}.
#' The class is generated by supplying a sub-intensity matrix and an optional
#' initial probability vector plus a reward matrix in the case of multivariate
#' phase-type.
#' If the initial probabilities are not specified, then the initial probability
#' will be \code{init_probs = c(1, 0, 0, ...)} with the same length as the
#' number of transient states.
#'
#' @param subint_mat is the square matrix containing the transition rates or
#'   probabilities between transient states for continous or discrete
#'   phase-type respectively.
#'   If the phase-type is continuous, the subintensity matrix diagonal should
#'   only contains negative values and the row sums should be non-positive.
#'   If the phase-type is discrete, the subintensity matrix should only contains
#'   values between 0 and 1.
#' @param init_probs a vector, a one-row matrix or \code{NULL} which gives the
#'   probabilities to start in each state. If init_probs is \code{NULL},
#'   the probability to start on the first state will be 1 and to start on any
#'   other state 0.
#' @param reward_mat is a matrix code{NULL}(default) where each row is a reward
#'   vector, and each column corresponds to a state. It should have the same
#'   number of columns as the length of the initial probabilities.
#' @param round_zero is an integer or \code{NULL}(default), which gives the
#'   decimal from which we should truncate the positive values of the
#'   subintensity matrix.
#'   It could be useful in the scenarios where there is a reward transformation
#'   leading to values with many decimals and potentially computational
#'   approximation and potentially to positive row sums in continuous phase-type
#'   .
#'
#' @usage phase_type(subint_mat = NULL, init_probs = NULL, reward_mat = NULL,
#'                   round_zero = NULL)
#'
#' @examples
#'
#' ##===========================##
#' ## For continuous univariate ##
#' ##===========================##
#'
#' subintensity_matrix <- matrix(c(-1.5, 0, 0,
#'                                1.5, -1, 0,
#'                                0, 1, -0.5), ncol = 3)
#' phase_type(subintensity_matrix)
#'
#' #---
#'
#' subintensity_matrix <- matrix(c(-1.5, 0, 0,
#'                                1.5, -1, 0,
#'                                0, 1, -0.5), ncol = 3)
#' initial_probabilities <- c(0.9, 0.1, 0)
#' phase_type(subintensity_matrix, initial_probabilities)
#'
#' ##=========================##
#' ## For discrete univariate ##
#' ##=========================##
#'
#' subintensity_matrix <- matrix(c(0.4, 0, 0,
#'                                0.24, 0.4, 0,
#'                                0.12, 0.2, 0.5), ncol = 3)
#' phase_type(subintensity_matrix)
#'
#' #---
#'
#' subintensity_matrix <- matrix(c(0.4, 0, 0,
#'                                0.24, 0.4, 0,
#'                                0.12, 0.2, 0.5), ncol = 3)
#' initial_probabilities <- c(0.9, 0.1, 0)
#' phase_type(subintensity_matrix, initial_probabilities)
#'
#' ##=============================##
#' ## For continuous multivariate ##
#' ##=============================##
#'
#' subintensity_matrix <- matrix(c(-3, 0, 0,
#'                                2, -2, 0,
#'                                0, 1, -1), nrow = 3, ncol = 3)
#' reward_matrix = matrix(sample(seq(0, 10, 0.1), 6), nrow = 3, ncol = 2)
#' phase_type(subintensity_matrix, reward_mat = reward_matrix)
#'
#' ##===========================##
#' ## For discrete multivariate ##
#' ##===========================##
#'
#' subintensity_matrix <- matrix(c(0.4, 0, 0,
#'                                0.24, 0.4, 0,
#'                                0.12, 0.2, 0.5), ncol = 3)
#' reward_matrix <- matrix(sample(seq(0, 10), 6), nrow = 3, ncol = 2)
#' phase_type(subintensity_matrix, reward_mat = reward_matrix)
#'
#' @export

phase_type <- function(subint_mat = NULL, init_probs = NULL,
                       reward_mat = NULL, round_zero = NULL) {
  #############
  # Check the conditions necessary for every phase-type distribution
  #############

  if (is.null(subint_mat)) {
    stop('Unable to construct the phase-type distribution.
         Please provide either the type or the subintensity matrix.')
  }

  if (!is.matrix(subint_mat)) {
    stop('The subintensity matrix should be a matrix.')
  } else {
    subint_mat <- matrix(as.numeric(subint_mat), ncol = ncol(subint_mat))
  }

  if (nrow(subint_mat) != ncol(subint_mat)){
    stop('Subintensity matrix should be a square numerical matrix.')
  }

  if (is.null(init_probs)) {
    init_probs <- matrix(c(1, rep(0, nrow(subint_mat) - 1)),
                         1, nrow(subint_mat))
    warning('The initial probability vector is automatically generated.')
  }

  if ((is.vector(init_probs) & is.atomic(init_probs)) | is.matrix(init_probs)) {
    init_probs <- as.numeric(init_probs)
    init_probs <- matrix(init_probs, nrow = 1)
    if (!is.null(round_zero)){
      if (round(round_zero) == round_zero) { # avoid positive value due to approximation
        init_probs[init_probs > 0] <- trunc(init_probs[init_probs > 0] *
                                              10^round_zero) / 10^round_zero
        subint_mat[subint_mat > 0] <- trunc(subint_mat[subint_mat > 0] *
                                              10^round_zero) / 10^round_zero
        print(trunc(subint_mat[subint_mat > 0],
                    round_zero))
      }
    }


    if (nrow(subint_mat) != length(init_probs)) {
      stop('The length of the initial probabilities does not match the size of
           the subintensity matrix.')
    }

    if (sum(init_probs) == 0){
      warning('The sum of the inital probability is equal to 0 with a defect
              of 1.')
    }

    if (sum(init_probs) < 0 || sum(init_probs) > 1){
      stop('The total initial probability should be between 0 and 1')
    } else if (sum(init_probs < 0) != 0 || sum(init_probs > 1) != 0) {
      stop('Each initial probability should be between 0 and 1.')
    }

  } else {
    stop('The initial probabilities must be a a matrix with one row or
         a vector.')
  }

  if (is.matrix(reward_mat)){
    if (sum(reward_mat < 0) < 0){
      stop('The reward matrix should only contains non-negative values.')
    }

    if (nrow(reward_mat) != length(init_probs)){
      stop('The reward matrix does not have the same number of columns as the
           number of states.')
    }
  }

  #############
  # Check the conditions necessary for continuous phase-type distribution
  #############

  if (length(which(diag(subint_mat) < 0)) == length(init_probs)) {

    if (sum(apply(subint_mat, 1, sum) > 0) > 0){
      stop('The row sums of the subintensity matrix should be non-positive.')
    }
    if (is.matrix(reward_mat)){
      value <- list(subint_mat = subint_mat,
                    init_probs = init_probs,
                    reward_mat = reward_mat,
                    defect = 1 - sum(init_probs))
      attr(value, "class") <- "mult_cont_phase_type"
      return(value)
    } else {
      value <- list(subint_mat = subint_mat,
                    init_probs = init_probs,
                    defect = 1 - sum(init_probs))
      attr(value, "class") <- "cont_phase_type"
      return(value)
    }

    #############
    # Check the conditions necessary for discrete phase-type distribution
    #############

  } else if (sum(subint_mat < 0) == 0){
    if (sum(rowSums(subint_mat > 1)) > 0){
      stop('The rowsums should be between 0 and 1.')
    }

    if (sum(subint_mat > 1) > 0){
      stop('The subintensity matrix should only contains values between
           0 and 1.')
    }

    if (is.matrix(reward_mat)){
      if (round(reward_mat) != reward_mat){
        stop('The reward matrix should only contains integers.')
      }
      value <- list(subint_mat = subint_mat,
                    init_probs = init_probs,
                    reward_mat = reward_mat,
                    defect = 1 - sum(init_probs))
      attr(value, "class") <- "mult_disc_phase_type"
      return(value)
    } else {
      value <- list(subint_mat = subint_mat,
                    init_probs = init_probs,
                    defect = 1 - sum(init_probs))
      attr(value, "class") <- "disc_phase_type"
      return(value)
    }

  } else {
    stop('This matrix is not valid for either discrete or continuous',
         'phase-type.')
  }
}


moment_ph <- function(obj, m) {
  e <- matrix(rep(1,nrow(obj$subint_mat)), nrow(obj$subint_mat), 1)
  inv <- solve(obj$subint_mat %^% m)
  moment <- as.numeric((-1) ** m * factorial(m) * obj$init_probs %*% inv %*% e)
  return(moment)
}


#' @describeIn phase_type mean of a phase-type distribution.
#' For the multivariate continuous distribution if an integer is provided in
#' \code{v},then the mean of the variable with the specified index in the
#' reward matrix is returned.
#' If instead a vector is provided, then the means of the variables defined
#' by those indices will be returned.
#' In case of not specifying \code{v}, the means of all the variables defined by
#' the sub-intensity matrix are returned (default).
#'
#' @export

mean.cont_phase_type <- function(x, ...) {
  moment_ph(x, 1)
}

#' @export

mean.disc_phase_type <- function(x, ...) {
  mean <- sum(x$init_probs %*% solve(diag(nrow = nrow(x$subint_mat))
                                     - x$subint_mat))
  mean <- as.numeric(mean + x$defect)
  return(mean)
}

#' @export

mean.mult_cont_phase_type <- function(x, v = NULL, ...) {
  if (!is.null(v)) {
    if (length(v) == 1) {
      return(moment_mph(x, v))
    } else {
      result <- matrix(NA, nrow = length(v))
      for (i in 1:length(v)) {
        result[i,] <- moment_mph(x, v[i])
      }
      return(result[,1])
    }
  } else {
    result <- matrix(NA, nrow = ncol(x$reward_mat))
    for (i in 1:nrow(result)) {
      result[i,] <- moment_mph(x, i)
    }
    return(result[,1])
  }
}

mean.mult_disc_phase_type <- function(x, v = NULL, ...){
  result <- rep(0, ncol(x$reward_mat))
  for (i in 1:ncol(x$reward_mat)){
    result[i] <- mean(reward_phase_type(x, x$reward_mat[,i]))
  }
  return(result)
}

#' Variance of phase-type distributions
#'
#' Calculates the variance of continuous, discrete and multivariate phase-type
#' distributions, represented by the \code{cont_phase_type},
#' \code{disc_phase_type} and \code{mult_cont_phase_type} classes respectively.
#'
#' For  the univariate case (\code{cont_phase_type} and \code{disc_phase_type}),
#' the variance of the distribution is returned.
#'
#' In the case of multivariate phase-type distributions three
#' different usages can be distinguished:
#' \itemize{
#'  \item{If \code{v = NULL} (default), then a variance-covariance matrix of all
#'  the variables specified in the reward matrix are returned, where variances
#'  are in the diagonal and covariances in the rest of the matrix element.}
#'  \item{If \code{v} is an integer, then the variance of the variable encoded
#'  by the \code{v} index in the reward matrix is returned.}
#'  \item{If \code{v} is a vector of length 2, then the covariance between the
#'  two variables encoded by the \code{v} indices in the reward matrix is
#'  returned.}
#' }
#'
#' @param obj a \code{cont_phase_type}, \code{disc_phase_type},
#'  \code{mult_cont_phase_type} or \code{mult_disc_phase_type} object
#' @param v NULL, integer or vector of length 2.
#'
#' @usage var(obj, ...)
#' @usage var(obj, v = NULL, ...)
#'
#' @export

var <- function(obj, ...) {
  UseMethod('var', obj)
}

#' @describeIn phase_type Gives the variance of a phase-type object,
#' see the specific documentation for further informations.
#' @export

var.cont_phase_type <- function(obj, ...) {
  moment_ph(obj, 2) - moment_ph(obj, 1) ** 2
}

#' @export

var.disc_phase_type <- function(obj) {
  variance <- sum(2 * obj$init_probs %*% obj$subint_mat %*%
                    solve((diag(nrow = nrow(obj$subint_mat))
                           -obj$subint_mat) %^% 2)) + mean(obj) - mean(obj)^2
  variance <- as.numeric(variance)
  return(variance)
}

#' @export

var.mult_cont_phase_type <- function(obj, v = NULL, ...) {
  if (is.null(v)) {
    cov_mat <- matrix(NA, ncol(obj$reward_mat), ncol(obj$reward_mat))
    for (i in 1:ncol(cov_mat)) {
      for (j in i:ncol(cov_mat)) {
        cov_mat[i, j] <- var(obj, c(i, j))
      }
    }
    cov_mat[lower.tri(cov_mat)] = t(cov_mat)[lower.tri(cov_mat)]
    return(cov_mat)
  } else if (length(v) == 1) {
    v <- rep(v, 2)
  } else if (length(v) != 2) {
    stop('Please provide the right indices')
  }
  var <- moment_mph(obj, v) - moment_mph(obj, v[1]) * moment_mph(obj, v[2])
  return(var)
}

#' @export

var.mult_disc_phase_type <- function(obj, v = NULL, ...){
  r <- obj$reward_mat
  n <- ncol(r)
  init <- obj$init_probs
  e <- matrix(1, nrow = length(init))
  I <- diag(1, length(init))
  U <- solve(I - obj$subint_mat)
  if (is.null(v)) {
    cov_mat <-  matrix(NA, ncol(obj$reward_mat), ncol(obj$reward_mat))
    for (i in 1:ncol(cov_mat)) {
      for (j in i:ncol(cov_mat)) {
        cov_mat[i, j] <- init %*% (U %*% diag(r[,i]) %*% U %*% diag(r[,j]) +
                                   U %*% diag(r[,j]) %*% U %*% diag(r[,i]) -
                                   U %*% diag(r[,i]) %*% diag(r[,j]) +
                                   U %*% diag(r[,i]) %*% e %*% init %*% U %*%
                                   diag(r[,j])) %*% e
      }
    }
    #cov_mat[lower.tri(cov_mat)] = t(cov_mat)[lower.tri(cov_mat)]
    return(cov_mat)
  } else if (length(v) == 1) {
    v = rep(v, 2)
  } else if (length(v) != 2) {
    stop('Please provide the right indices')
  }
  var <- init %*% (U %*% diag(r[,v[1]]) %*% U %*% diag(r[,v[2]]) +
                     U %*% diag(r[,v[2]]) %*% U %*% diag(r[,v[1]]) -
                     U %*% diag(r[,v[1]]) %*% diag(r[,v[2]]) +
                     U %*% diag(r[,v[1]]) %*% e %*% init %*% U %*%
                     diag(r[,v[2]])) %*% e
  var = as.numeric(var)
  return(var)
}

#' @describeIn phase_type pretty summary of the class.
#'
#' @export

summary.cont_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
  cat('\nMean: ', mean(object), '\n', sep = '')
  cat('\nVariance: ', var(object), '\n\n', sep = '')
}

#' @export

summary.disc_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
  cat('\nMean: ', mean(object), '\n', sep = '')
  cat('\nVariance: ', var(object), '\n\n', sep = '')
}

#' @export

summary.mult_cont_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nReward matrix:\n')
  print(object$reward_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
}

#' @export

summary.mult_disc_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nReward matrix:\n')
  print(object$reward_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
}

moment_individual <- function(element, obj){
  solve(-obj$subint_mat) %*% diag(obj$reward_mat[,element])
}

moment_row <- function(row, obj) {
  total <- diag(1, nrow(obj$subint_mat), ncol(obj$subint_mat))
  for (individual in lapply(row, moment_individual, obj = obj)) {
    total <- total %*% individual
  }
  sum(obj$init_probs %*% total)
}

perm <- function(v) {
  n <- length(v)
  if (n == 1) v
  else {
    X <- NULL
    for (i in 1:n) X <- rbind(X, cbind(v[i], perm(v[-i])))
    return(X)
  }
}

#' Moments of the multivariate phase-type distribution
#'
#' This function calculates the moments for the multivariate phase-type
#' distributions.
#'
#' The variables for which the moments are calculated can be specified in
#' the \code{v} vector as indices in the reward matrix of the
#' \code{mult_cont_phase_type} object.
#'
#' @param obj a mult_cont_phase_type.
#' @param v a vector or an integer.
#'
#' @usage moment_ph(obj, v)
#'
#' @export

moment_mph <- function(obj, v) {
  v <- matrix(v)
  X <- perm(v)
  sum(apply(X, 1, moment_row, obj = obj))
}

# require the partitions::parts() function (or write it again)
moment_mdph <- function(obj, v){
  Pv <- partitions::parts(v)
  udrj <- list()
  for (s in 1:v){
  }
}


