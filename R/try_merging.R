#' \code{cont_phase_type} class
#'
#' Description of the class \code{cont_phase_type}, which represents continuous phase-type
#' distributions.
#'
#' \code{cont_phase_type} is the generator function for the continuous phase-type distribution class
#' of the same name, which inherits from \code{list}. The class is generated by supplying a sub-intensity
#' matrix and an optional initial probability vector. If the initial probabilities are not specified,
#' then they are automatically generated as the first state having a probability of 1 and the rest
#' a probability of 0.
#'
#' @param subint_mat matrix
#' @param init_probs vector, a one-row matrix or \code{NULL}.
#'
#' @usage cont_phase_type(subint_mat = NULL, init_probs = NULL)
#'
#' @examples
#' subintensity_matrix = matrix(c(-1.5, 0, 0,
#'                                1.5, -1, 0,
#'                                0, 1, -0.5), ncol = 3)
#' cont_phase_type(subintensity_matrix)
#'
#' #---
#'
#' subintensity_matrix = matrix(c(-1.5, 0, 0,
#'                                1.5, -1, 0,
#'                                0, 1, -0.5), ncol = 3)
#' initial_probabilities = c(0.9, 0.1, 0)
#' cont_phase_type(subintensity_matrix, initial_probabilities)
#'
#' @export

try_merging <- function(subint_mat = NULL, init_probs = NULL) {
  if (is.null(subint_mat)) {

    stop('Unable to construct the phase-type distribution.
         Please provide either the type or the subintensity matrix.')

  } else if (is.matrix(subint_mat)) {


    if (nrow(subint_mat) != ncol(subint_mat)){
      stop('Subintensity matrix should be a square numerical matrix')
    }

    if (is.null(init_probs)) {

      init_probs <- matrix(c(1, rep(0, nrow(subint_mat) - 1)),
                           1, nrow(subint_mat))
      warning('The initial probability vector is automatically generated.')

    }

    if ((is.vector(init_probs) & is.atomic(init_probs)) | is.matrix(init_probs)) {

      if (nrow(subint_mat) == length(init_probs)) {

        init_probs <- matrix(init_probs, nrow = 1)

        if (sum(init_probs) == 0){
          warning('The sum of the inital probability is equal to 0
                  with a defect of 1')
        }
        if (sum(init_probs) < 0 | sum(init_probs) > 1){
          stop('The total initial probability should be between 0 and 1')
        } else if (sum(init_probs < 0) != 0 || sum(init_probs > 1) != 0) {
          stop('Each initial probability should be between 0 and 1')
        } else if (is.element(0,diag(subint_mat))){
          stop('The subintensity matrix should not contains 0 on its diagonal')
        }

      } else {

        stop('The length of the initial probabilities
             does not match the size of the subintensity matrix.')
      }
    } else {
      stop('The initial probabilities
           must be a a matrix with one row or a vector.')
    }

    if (sum(rowSums(subint_mat) > 0) == 0) {
      value <- list(subint_mat = subint_mat,
                    init_probs = init_probs,
                    defect = 1-sum(init_probs))
      attr(value, "class") <- "cont_phase_type"
      value


    } else if (sum(subint_mat < 0) == 0){
      if (sum(rowSums(subint_mat > 1)) == 0){
        value <- list(subint_mat = subint_mat,
                      init_probs = init_probs,
                      defect = 1-sum(init_probs))
        attr(value, "class") <- "disc_phase_type"
        value
      }else{
        stop('The rowsums should be between 0 and 1')
      }

    } else {
      stop('This matrix is not valid for either
           discrete or continuous phase-type')
    }


  } else {
    stop('The subintensity matrix must be a matrix.')
  }

}


moment_ph <- function(obj, m) {
  e <- matrix(rep(1,nrow(obj$subint_mat)), nrow(obj$subint_mat), 1)
  inv <- solve(obj$subint_mat%^%m)
  as.numeric((-1)**m*factorial(m)*obj$init_probs%*%inv%*%e)
}


#' @describeIn cont_phase_type mean of the continuous phase-type distribution.
#'
#' @export

mean.cont_phase_type <- function(x, ...) {
  moment_ph(x, 1)
}

#' Variance of phase-type distributions
#'
#' Calculates the variance of continuous, discrete and multivariate phase-type distributions,
#' represented by the \code{cont_phase_type}, \code{disc_phase_type} and \code{mult_phase_type} classes
#' respectively.
#'
#' For  the univariate case (\code{cont_phase_type} and \code{disc_phase_type}), the variance of
#' the distribution is returned. In the case of multivariate phase-type distributions three
#' different usages can be distinguished:
#' \itemize{
#'  \item{If \code{v = NULL} (default), then a variance-covariance matrix of all the variables specified
#'  in the reward matrix is returned, where variances are in the diagonal and covariances in the rest of
#'  the matrix element.}
#'  \item{If \code{v} is an integer, then the variance of the variable encoded by the \code{v} index in
#'  the reward matrix is returned.}
#'  \item{If \code{v} is a vector of length 2, then the covariance between the two variables encoded by
#'  the \code{v} indices in the reward matrix is returned.}
#' }
#'
#' @param obj a \code{cont_phase_type}, \code{disc_phase_type} or \code{mult_phase_type}
#' @param v NULL, integer or vector of length 2.
#'
#' @usage var(obj, ...)
#' @usage var(obj, v = NULL, ...)
#'
#' @export

var <- function(obj, ...) {
  UseMethod('var', obj)
}

#' @describeIn cont_phase_type variance of the continuous phase-type distribution.
#'
#' @export

var.cont_phase_type <- function(obj, ...) {
  moment_ph(obj, 2)-moment_ph(obj, 1)**2
}

#' @describeIn cont_phase_type pretty summary of the continuous phase-type distribution.
#'
#' @export

summary.cont_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
  cat('\nMean: ', mean(object), '\n', sep = '')
  cat('\nVariance: ', var(object), '\n\n', sep = '')
}
