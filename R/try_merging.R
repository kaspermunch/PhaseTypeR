#' \code{cont_phase_type} class
#'
#' Description of the class \code{cont_phase_type}, which represents continuous phase-type
#' distributions.
#'
#' \code{cont_phase_type} is the generator function for the continuous phase-type distribution class
#' of the same name, which inherits from \code{list}. The class is generated by supplying a sub-intensity
#' matrix and an optional initial probability vector. If the initial probabilities are not specified,
#' then they are automatically generated as the first state having a probability of 1 and the rest
#' a probability of 0.
#'
#' @param subint_mat matrix
#' @param init_probs vector, a one-row matrix or \code{NULL}.
#'
#' @usage cont_phase_type(subint_mat = NULL, init_probs = NULL)
#'
#' @examples
#' subintensity_matrix = matrix(c(-1.5, 0, 0,
#'                                1.5, -1, 0,
#'                                0, 1, -0.5), ncol = 3)
#' cont_phase_type(subintensity_matrix)
#'
#' #---
#'
#' subintensity_matrix = matrix(c(-1.5, 0, 0,
#'                                1.5, -1, 0,
#'                                0, 1, -0.5), ncol = 3)
#' initial_probabilities = c(0.9, 0.1, 0)
#' cont_phase_type(subintensity_matrix, initial_probabilities)
#'
#' @export

try_merging <- function(subint_mat = NULL,
                        init_probs = NULL, reward_mat = NULL) {
  if (is.null(subint_mat)) {

    stop('Unable to construct the phase-type distribution.
         Please provide either the type or the subintensity matrix.')

  } else if (is.matrix(subint_mat)) {


    if (nrow(subint_mat) != ncol(subint_mat)){
      stop('Subintensity matrix should be a square numerical matrix')
    }

    if (is.null(init_probs)) {

      init_probs <- matrix(c(1, rep(0, nrow(subint_mat) - 1)),
                           1, nrow(subint_mat))
      warning('The initial probability vector is automatically generated.')

    }

    if ((is.vector(init_probs) & is.atomic(init_probs)) | is.matrix(init_probs)) {

      if (nrow(subint_mat) == length(init_probs)) {

        init_probs <- matrix(init_probs, nrow = 1)

        if (sum(init_probs) == 0){
          warning('The sum of the inital probability is equal to 0
                  with a defect of 1')
        }
        if (sum(init_probs) < 0 | sum(init_probs) > 1){
          stop('The total initial probability should be between 0 and 1')
        } else if (sum(init_probs < 0) != 0 || sum(init_probs > 1) != 0) {
          stop('Each initial probability should be between 0 and 1')
        } else if (is.element(0,diag(subint_mat))){
          stop('The subintensity matrix should not contains 0 on its diagonal')
        }

      } else {

        stop('The length of the initial probabilities
             does not match the size of the subintensity matrix.')
      }
    } else {
      stop('The initial probabilities
           must be a a matrix with one row or a vector.')
    }

    if (sum(rowSums(subint_mat) > 0) == 0) {
      if (is.matrix(reward_mat)){
        value <- list(subint_mat = subint_mat,
                      init_probs = init_probs,
                      reward_mat = reward_mat,
                      defect = 1-sum(init_probs))
        attr(value, "class") <- "mult_cont_phase_type"
        return(value)
      } else {
        value <- list(subint_mat = subint_mat,
                      init_probs = init_probs,
                      defect = 1-sum(init_probs))
        attr(value, "class") <- "cont_phase_type"
        return(value)
      }



    } else if (sum(subint_mat < 0) == 0){
      if (sum(rowSums(subint_mat > 1)) == 0){
        if (is.matrix(reward_mat)){
          value <- list(subint_mat = subint_mat,
                        init_probs = init_probs,
                        reward_mat = reward_mat,
                        defect = 1-sum(init_probs))
          attr(value, "class") <- "disc_phase_type"
          return(value)

        } else {
          value <- list(subint_mat = subint_mat,
                        init_probs = init_probs,
                        defect = 1-sum(init_probs))
          attr(value, "class") <- "disc_phase_type"
          return(value)
        }

      }else{
        stop('The rowsums should be between 0 and 1')
      }

    } else {
      stop('This matrix is not valid for either
           discrete or continuous phase-type')
    }


  } else {
    stop('The subintensity matrix must be a matrix.')
  }

}


moment_ph <- function(obj, m) {
  e <- matrix(rep(1,nrow(obj$subint_mat)), nrow(obj$subint_mat), 1)
  inv <- solve(obj$subint_mat%^%m)
  as.numeric((-1)**m*factorial(m)*obj$init_probs%*%inv%*%e)
}


#' @describeIn cont_phase_type mean of the continuous phase-type distribution.
#'
#' @export

mean.cont_phase_type <- function(x, ...) {
  moment_ph(x, 1)
}

#' Variance of phase-type distributions
#'
#' Calculates the variance of continuous, discrete and multivariate phase-type distributions,
#' represented by the \code{cont_phase_type}, \code{disc_phase_type} and \code{mult_phase_type} classes
#' respectively.
#'
#' For  the univariate case (\code{cont_phase_type} and \code{disc_phase_type}), the variance of
#' the distribution is returned. In the case of multivariate phase-type distributions three
#' different usages can be distinguished:
#' \itemize{
#'  \item{If \code{v = NULL} (default), then a variance-covariance matrix of all the variables specified
#'  in the reward matrix is returned, where variances are in the diagonal and covariances in the rest of
#'  the matrix element.}
#'  \item{If \code{v} is an integer, then the variance of the variable encoded by the \code{v} index in
#'  the reward matrix is returned.}
#'  \item{If \code{v} is a vector of length 2, then the covariance between the two variables encoded by
#'  the \code{v} indices in the reward matrix is returned.}
#' }
#'
#' @param obj a \code{cont_phase_type}, \code{disc_phase_type} or \code{mult_phase_type}
#' @param v NULL, integer or vector of length 2.
#'
#' @usage var(obj, ...)
#' @usage var(obj, v = NULL, ...)
#'
#' @export

var <- function(obj, ...) {
  UseMethod('var', obj)
}

#' @describeIn cont_phase_type variance of the continuous phase-type distribution.
#'
#' @export

var.cont_phase_type <- function(obj, ...) {
  moment_ph(obj, 2)-moment_ph(obj, 1)**2
}

#' @describeIn cont_phase_type pretty summary of the continuous phase-type distribution.
#'
#' @export

summary.cont_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
  cat('\nMean: ', mean(object), '\n', sep = '')
  cat('\nVariance: ', var(object), '\n\n', sep = '')
}

#' @describeIn disc_phase_type mean of the discrete phase-type distribution.
#'
#' @export

mean.disc_phase_type <- function(x, ...) {
  mean <- sum(x$init_probs%*%solve(diag(nrow = nrow(x$subint_mat))-x$subint_mat))
  as.numeric(mean+x$defect)
}

#' @describeIn disc_phase_type variance of the discrete phase-type distribution.
#'
#' @export

var.disc_phase_type <- function(obj) {
  variance <- sum(2*obj$init_probs%*%obj$subint_mat%*%solve((diag(nrow = nrow(obj$subint_mat))-obj$subint_mat)%^%2)) +
    mean(obj) -
    mean(obj)^2
  as.numeric(variance)
}

#' @describeIn disc_phase_type pretty summary of the discrete phase-type distribution.
#'
#' @export

summary.disc_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
  cat('\nMean: ', mean(object), '\n', sep = '')
  cat('\nVariance: ', var(object), '\n\n', sep = '')
}

#' @describeIn mult_phase_type pretty summary of the class.
#'
#' @export

summary.mult_cont_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nReward matrix:\n')
  print(object$reward_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
}






moment_individual <- function(element, obj){
  solve(-obj$subint_mat)%*%diag(obj$reward_mat[,element])
}

moment_row <- function(row, obj) {
  total <- diag(1, nrow(obj$subint_mat), ncol(obj$subint_mat))
  for (individual in lapply(row, moment_individual, obj = obj)) {
    total <- total%*%individual
  }
  sum(obj$init_probs%*%total)
}

perm <- function(v) {
  n <- length(v)
  if (n == 1) v
  else {
    X <- NULL
    for (i in 1:n) X <- rbind(X, cbind(v[i], perm(v[-i])))
    X
  }
}




#' Moments of the multivariate phase-type distribution
#'
#' This function calculates the moments for the multivariate phase-type distributions.
#'
#' The variables for which the moments are calculated can be specified in the \code{v}
#' vector as indices in the reward matrix of the \code{mult_phase_type} object.
#'
#' @param obj a mult_phase_type.
#' @param v a vector or an integer.
#'
#' @usage moment_ph(obj, v)
#'
#' @export

moment_mph <- function(obj, v) {
  v = matrix(v)
  X = perm(v)
  sum(apply(X, 1, moment_row, obj = obj))
}


#' @describeIn mult_phase_type if an integer is provided in \code{v}, then the mean of
#' the variable with the specified index in the reward matrix is returned. If instead a
#' vector is provided, then the means of the variables defined by those indices will be
#' returned. In case of not specifying \code{v}, the means of all the variables defined by
#' the sub-intensity matrix are returned (default).
#'
#' @export

mean.mult_cont_phase_type <- function(x, v = NULL, ...) {
  if (!is.null(v)) {
    if (length(v) == 1) {
      return(moment_mph(x, v))
    } else {
      result <- matrix(NA, nrow = length(v))
      for (i in 1:length(v)) {
        result[i,] <- moment_mph(x, v[i])
      }
      return(result[,1])
    }
  } else {
    result <- matrix(NA, nrow = ncol(x$reward_mat))
    for (i in 1:nrow(result)) {
      result[i,] <- moment_mph(x, i)
    }
    return(result[,1])
  }
}

#' @describeIn mult_phase_type if an integer is provided in \code{v}, then the variance of
#' the variable with the specified index in the reward matrix is returned. If instead a
#' vector of length 2 is provided, then the covariance of the variables defined by those indices will be
#' returned. In case of not specifying \code{v}, the variance-covariance matrix between all the variables defined by
#' the sub-intensity matrix are returned (default).
#'
#' @export

var.mult_cont_phase_type <- function(obj, v = NULL, ...) {
  if (is.null(v)) {
    cov_mat = matrix(NA, ncol(obj$reward_mat), ncol(obj$reward_mat))
    for (i in 1:ncol(cov_mat)) {
      for (j in i:ncol(cov_mat)) {
        cov_mat[i, j] <- var(obj, c(i, j))
      }
    }
    cov_mat[lower.tri(cov_mat)] = t(cov_mat)[lower.tri(cov_mat)]
    return(cov_mat)
  } else if (length(v) == 1) {
    v <- rep(v, 2)
  } else if (!(length(v) == 2)) {
    stop('Please provide the right indices')
  }
  moment_mph(obj, v) - moment_mph(obj, v[1])*moment_mph(obj, v[2])
}
