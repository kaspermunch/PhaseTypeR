#' \code{mult_phase_type} class
#'
#' Description of the class \code{mult_phase_type}, which represents the multivariate phase-type
#' distribution.
#'
#' \code{cont_phase_type} is the generator function for the multivariate phase-type distribution class
#' of the same name, which inherits from \code{list}. The class is generated by supplying a sub-intensity
#' matrix, an optional initial probability vector and a reward matrix. If the initial probabilities are not specified,
#' then they are automatically generated as the first state having a probability of 1 and the rest
#' a probability of 0.
#'
#' @param subint_mat matrix
#' @param init_probs vector, a one-row matrix or \code{NULL}.
#' @param reward_mat matrix
#'
#' @usage mult_phase_type(subint_mat = NULL, reward_mat = NULL, init_probs = NULL)
#'
#' @examples
#' subint_mat = matrix(c(-3, 0, 0, 2, -2, 0, 0, 1, -1), nrow = 3, ncol = 3)
#' reward_mat = matrix(sample(seq(0, 10), 6), nrow = 3, ncol = 2)
#' mult_phase_type(subint_mat, reward_mat)
#'
#' @export

mult_phase_type <- function(subint_mat = NULL, reward_mat = NULL, init_probs = NULL) {
  if (is.null(subint_mat)) {
    stop('Unable to construct the phase-type distribution. Please provide a valid subintensity matrix.')
  } else if (is.matrix(subint_mat)) {
    if (is.null(init_probs)) {
      init_probs <- matrix(c(1, rep(0, nrow(subint_mat) - 1)), 1, nrow(subint_mat))
      warning('The initial probability vector is automatically generated.')
    } else if (sum(rowSums(subint_mat) > 0) != 0) {
      stop('The rowsums in subintensity matrix have to be non-positive')
    } else if ((is.vector(init_probs) & is.atomic(init_probs)) | is.matrix(init_probs)) {
      if (nrow(subint_mat) == length(init_probs)) {
        init_probs <- matrix(init_probs, nrow = 1)
      } else {
        stop('The length of the initial probabilities does not match the size of the subintensity matrix.')
      }
    } else {
      stop('The initial probabilities must be a a matrix with one row or a vector.')
    }
  } else {
    stop('The subintensity matrix must be a matrix.')
  }

  if (is.null(reward_mat)) {
    stop('Unable to construct the phase-type distribution. Please provide a valid reward matrix.')
  } else if (is.matrix(reward_mat)){
    if (nrow(reward_mat) != nrow(subint_mat)) {
      stop('The number of rows in the reward matrix does not match the number of rows in the subintensity matrix.')
    }
  } else {
    stop('The reward matrix must be a matrix.')
  }


  value <- list(subint_mat = subint_mat,
                init_probs = init_probs,
                defect = 1-sum(init_probs),
                reward_mat = reward_mat)
  attr(value, "class") <- "mult_phase_type"
  value
}


#' @export

summary.mult_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nReward matrix:\n')
  print(object$reward_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nDefect:\n')
  print(object$defect)
}






moment_individual <- function(element, obj){
  solve(-obj$subint_mat)%*%diag(obj$reward_mat[,element])
}

moment_row <- function(row, obj) {
  total <- diag(1, nrow(obj$subint_mat), ncol(obj$subint_mat))
  for (individual in lapply(row, moment_individual, obj = obj)) {
    total <- total%*%individual
  }
  sum(obj$init_probs%*%total)
}

perm <- function(v) {
  n <- length(v)
  if (n == 1) v
  else {
    X <- NULL
    for (i in 1:n) X <- rbind(X, cbind(v[i], perm(v[-i])))
    X
  }
}




#' Moments of the multivariate phase-type distribution
#'
#' This function calculates the moments for the multivariate phase-type distributions.
#'
#' The variables for which the moments are calculated can be specified in the \code{v}
#' vector as indices in the reward matrix of the \code{mult_phase_type} object.
#'
#' @param obj a mult_phase_type.
#' @param v a vector.
#'
#' @usage moment_ph(obj, v)
#'
#' @export

moment_mph <- function(obj, v) {
  v = matrix(v)
  X = perm(v)
  sum(apply(X, 1, moment_row, obj = obj))
}


#' @export

mean.mult_phase_type <- function(x, v = NULL, ...) {
  if (!is.null(v)) {
    if (length(v) == 1) {
      return(moment_mph(x, v))
    } else {
      result <- matrix(NA, nrow = length(v))
      for (i in 1:length(v)) {
        result[i,] <- moment_mph(x, v[i])
      }
      return(result[,1])
    }
  } else {
    result <- matrix(NA, nrow = ncol(x$reward_mat))
    for (i in 1:nrow(result)) {
      result[i,] <- moment_mph(x, i)
    }
    return(result[,1])
  }
}


#' @export

var.mult_phase_type <- function(obj, v = NULL, ...) {
  if (is.null(v)) {
    cov_mat = matrix(NA, ncol(obj$reward_mat), ncol(obj$reward_mat))
    for (i in 1:ncol(cov_mat)) {
      for (j in i:ncol(cov_mat)) {
        cov_mat[i, j] <- var(obj, c(i, j))
      }
    }
    cov_mat[lower.tri(cov_mat)] = t(cov_mat)[lower.tri(cov_mat)]
    return(cov_mat)
  } else if (length(v) == 1) {
    v <- rep(v, 2)
  } else if (!(length(v) == 2)) {
    stop('Please provide the right indices')
  }
  moment_mph(obj, v) - moment_mph(obj, v[1])*moment_mph(obj, v[2])
}


















