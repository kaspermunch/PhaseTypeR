#' \code{mult_phase_type} class
#'
#' Description of the class \code{mult_phase_type}, which represents the multivariate phase-type
#' distribution.
#'
#' \code{cont_phase_type} is the generator function for the multivariate phase-type distribution class
#' of the same name, which inherits from \code{list}. The class is generated by supplying a sub-intensity
#' matrix, an optional initial probability vector and a reward matrix. If the initial probabilities are not specified,
#' then they are automatically generated as the first state having a probability of 1 and the rest
#' a probability of 0.
#'
#' @param subint_mat matrix
#' @param init_probs vector, a one-row matrix or \code{NULL}.
#' @param reward_mat matrix
#'
#' @usage mult_phase_type(subint_mat = NULL, reward_mat = NULL, init_probs = NULL)
#'
#' @examples
#' subint_mat = matrix(c(0.4, 0, 0,
#'                       0.24, 0.4, 0,
#'                       0.12, 0.2, 0.5), ncol = 3)
#' reward_mat = matrix(sample(seq(0, 10), 6), nrow = 3, ncol = 2)
#' mult_disc_phase_type(subint_mat, reward_mat)
#'
#' @export

mult_disc_phase_type <- function(subint_mat = NULL,
                                 reward_mat = NULL, init_probs = NULL) {

  disc_phase_type(subint_mat, init_probs)

  if (is.null(init_probs)) {
    init_probs <- matrix(c(1, rep(0, nrow(subint_mat) - 1)), 1, nrow(subint_mat))
  }

  for (col in 1:ncol(reward_mat)){

    if (length(reward_mat[,col]) != length(init_probs)){
      stop('The reward vector has wrong dimensions (should be of the
                   same size that the inital probabilities).')
    }

    if (sum(reward_mat[,col] < 0) != 0){
      stop('The reward vector should only contains non-negative values.')
    }

    if (sum(reward_mat[,col]) != sum(round(reward_mat[,col]))){
      stop('The reward vector should only contains integer.')
    }
  }

  value <- list(subint_mat = subint_mat,
                init_probs = init_probs,
                defect = 1-sum(init_probs),
                reward_mat = reward_mat)
  attr(value, "class") <- "mult_disc_phase_type"
  return(value)
}

#' @describeIn mult_phase_type pretty summary of the class.
#'
#' @export

summary.mult_phase_type <- function(object, ...) {
  cat('\nSubintensity matrix:\n')
  print(object$subint_mat)
  cat('\nReward matrix:\n')
  print(object$reward_mat)
  cat('\nInitial probabilities:\n')
  print(object$init_probs)
  cat('\nInitial Defect:\n') # Before the applications of any reward.
  print(object$defect)
}









moment_individual <- function(element, obj){
  solve(-obj$subint_mat)%*%diag(obj$reward_mat[,element])
}

moment_row <- function(row, obj) {
  total <- diag(1, nrow(obj$subint_mat), ncol(obj$subint_mat))
  for (individual in lapply(row, moment_individual, obj = obj)) {
    total <- total%*%individual
  }
  sum(obj$init_probs%*%total)
}

perm <- function(v) {
  n <- length(v)
  if (n == 1) v
  else {
    X <- NULL
    for (i in 1:n) X <- rbind(X, cbind(v[i], perm(v[-i])))
    X
  }
}




#' Moments of the multivariate phase-type distribution
#'
#' This function calculates the moments for the multivariate phase-type distributions.
#'
#' The variables for which the moments are calculated can be specified in the \code{v}
#' vector as indices in the reward matrix of the \code{mult_phase_type} object.
#'
#' @param obj a mult_phase_type.
#' @param v a vector or an integer.
#'
#' @usage moment_ph(obj, v)
#'
#' @export

moment_mph <- function(obj, v) {
  v = matrix(v)
  X = perm(v)
  sum(apply(X, 1, moment_row, obj = obj))
}


#' @describeIn mult_phase_type if an integer is provided in \code{v}, then the mean of
#' the variable with the specified index in the reward matrix is returned. If instead a
#' vector is provided, then the means of the variables defined by those indices will be
#' returned. In case of not specifying \code{v}, the means of all the variables defined by
#' the sub-intensity matrix are returned (default).
#'
#' @export

mean.mult_phase_type <- function(x, v = NULL, ...) {
  if (!is.null(v)) {
    if (length(v) == 1) {
      return(moment_mph(x, v))
    } else {
      result <- matrix(NA, nrow = length(v))
      for (i in 1:length(v)) {
        result[i,] <- moment_mph(x, v[i])
      }
      return(result[,1])
    }
  } else {
    result <- matrix(NA, nrow = ncol(x$reward_mat))
    for (i in 1:nrow(result)) {
      result[i,] <- moment_mph(x, i)
    }
    return(result[,1])
  }
}

#' @describeIn mult_phase_type if an integer is provided in \code{v}, then the variance of
#' the variable with the specified index in the reward matrix is returned. If instead a
#' vector of length 2 is provided, then the covariance of the variables defined by those indices will be
#' returned. In case of not specifying \code{v}, the variance-covariance matrix between all the variables defined by
#' the sub-intensity matrix are returned (default).
#'
#' @export

var.mult_phase_type <- function(obj, v = NULL, ...) {
  if (is.null(v)) {
    cov_mat = matrix(NA, ncol(obj$reward_mat), ncol(obj$reward_mat))
    for (i in 1:ncol(cov_mat)) {
      for (j in i:ncol(cov_mat)) {
        cov_mat[i, j] <- var(obj, c(i, j))
      }
    }
    cov_mat[lower.tri(cov_mat)] = t(cov_mat)[lower.tri(cov_mat)]
    return(cov_mat)
  } else if (length(v) == 1) {
    v <- rep(v, 2)
  } else if (!(length(v) == 2)) {
    stop('Please provide the right indices')
  }
  moment_mph(obj, v) - moment_mph(obj, v[1])*moment_mph(obj, v[2])
}

subint_mat = matrix(c(0.4, 0, 0,
                      0.24, 0.4, 0,
                      0.12, 0.2, 0.5), ncol = 3)
reward_mat = matrix(sample(seq(0, 10), 6), nrow = 3, ncol = 2)
mult_disc_phase_type(subint_mat, reward_mat)

#######

#joint prob distr

subint_mat = matrix(c(0.4, 0, 0,
                     0.24, 0.4, 0,
                     0.12, 0.2, 0.5), ncol = 3)
reward_mat = matrix(sample(seq(0, 10), 6), nrow = 3, ncol = 2)
a = mult_disc_phase_type(subint_mat, reward_mat)

joint_prob_MDPH = function(MDPH, theta){
  R = MDPH$reward
  theta_r = vector()
  for (i in 1:nrow(R)){
    theta_r[i] = prod(theta^(R[i,]))
  }
  p = length(MDPH$init_probs)
  theta_r = diag(theta_r)
  e = rep(1, p)
  I = diag(e)
  T_mat = MDPH$subint_mat
  pi_absorbing = MDPH$defect
  jPGF = pi_absorbing + MDPH$init_probs %*% theta_r %*%
    solve(I - T_mat %*% theta_r) %*% (e - T_mat %*% e)
  return(jPGF)
}

joint_moment_MDPH = function(MDPH, u){
  R = MDPH$reward
  eur = vector()
  for (i in 1:nrow(R)){
    eur[i] = exp(sum(u*(R[i,])))
  }
  p = length(MDPH$init_probs)
  diag_eur = diag(eur)
  e = rep(1, p)
  I = diag(e)
  T_mat = MDPH$subint_mat

  jMGF = MDPH$init_probs %*% diag_eur %*%
    solve(I - T_mat %*% diag_eur) %*% (e - T_mat %*% e)
  return(jMGF)
}

library(rgl)
x = matrix(0,nrow = 100, ncol = 100)

counti = 1
countj = 1
for (i in seq(-1,1,length.out = 100)){
  for (j in seq(-1,1,length.out = 100)){
    x[counti,countj] = joint_moment_MDPH(a, c(i,j))
    countj = countj+1
  }
  counti = counti+1
  countj = 1
}

rgl.open()

plot3D::hist3D(z=x)

plot(x[70,])
rgl.points(x=seq(0,100,length.out = nrow(x)),
          y=seq(0,100,length.out = nrow(x)),
          z=x,
          theta = 240)

moment_m = function(MDPH, m){
  U = solve(I - MDPH$subint_mat)
  drjsigma = diag(rj^sigmals/factorial(sigmals))
  udrjsigma = -U %*% drjsigma
  (-1)^m * factorial(m) * MDPH$init_distr * sum(prod())
}










