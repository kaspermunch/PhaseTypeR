---
title: "Using phasty for the site frequency spectrum"
output:
  html_document:
    includes:
      before_body: preamble-mathjax.tex
    toc: true
vignette: >
  %\VignetteIndexEntry{Using phasty for the site frequency spectrum}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = F,
  error = F
)
```

# 1. Introduction 

Here we recreate the figures from the paper and give more example of how to use the phase-type representation of the block counting process.


```{r setup}
library(phasty)
```

First, a sanity check, we recover the numerical values of the covariance matrix for the site frequency spectrum, which is also computed on p. 5 of Durrett. 


```{r}
n = 8
ph_rew_obj = block_counting_process(n)
round(0.25*var(ph_rew_obj),4)
```

Next, we recreate some of the figures in the paper

```{r}
n = 10
ph_rew_obj = block_counting_process(n)
lambdavals = c(0.02,0.2,1,2,10)
coef_matrix = matrix(0,length(lambdavals),n-1)
nu = 1/(1:(n-1) )
for(i in 1:length(lambdavals)) {
  lambda = lambdavals[i]
  bLambda=lambda^2*var(ph_rew_obj) + lambda*diag( mean(ph_rew_obj) )
  coef_matrix[i,]=solve(bLambda)%*%nu/c(nu%*%solve(bLambda)%*%nu)
}

plot(coef_matrix[1,],type="l",las=1,ylab="Coefficient",ylim=c(-0.5,2))
for(i in 2:length(lambdavals)) {
  lines(coef_matrix[i,])
}
```

Next, we numerically invert the characteristic function of the numerator of Tajima's $D$ and compare to simulated values. First, we obtain the rate-matrix and state space for the block counting process. 

```{r}
n = 4
# create rate-matrix and state space for block counting process
RMASS = RateMAndStateSpace(n)

m = dim(RMASS$RateM)[1] #(m should be equal to partitions::P(n))

# Obtain subintensity matrix
subintensity_matrix = RMASS$RateM[1:(m-1),1:(m-1)]

# The reward matrix is the state space matrix of the block counting process, except the row & column related to the
# aborping state.
rew_mat = RMASS$StSpM[1:(m-1),1:(n-1)]

bT=RMASS$RateM[1:(dim(RMASS$RateM)[1]-1),1:(dim(RMASS$RateM)[1]-1)]
SPMAT=RMASS$StSpM[1:(dim(RMASS$StSpM)[1]-1),1:(dim(RMASS$StSpM)[2]-1)]
bone = matrix(1,dim(bT)[1],1) #(1,1,...,1)*
alpha = matrix(0,1,dim(bT)[1]);alpha[1]=1 #(1,0,...,0)
bR = SPMAT #the rewards matrix *is* the statespace matrix
bS = bT - diag(rowSums(bR))


ph_obj=phase_type(subintensity_matrix)
ph_rew_obj=phase_type(subintensity_matrix, reward_mat = rew_mat)
```

Next, we simulate random site frequency spectra by using REF

```{r}
R = 1e4
ph_mv_sim_obj = sim_rew_phase_type(R,ph_rew_obj)
rew_dim = dim(ph_mv_sim_obj)[1]
lambda = 1
ph_counts = matrix(0,rew_dim,dim(ph_mv_sim_obj)[2])
for(i in 1:rew_dim) {
  ph_counts[i,] = rpois(R,lambda*ph_mv_sim_obj[i,])
}
```

An alternative is to simulate the SFS using the coalo package

```{r}
library(coala)
loc_length = 1e4; theta = 3
model <- coal_model(sample_size = n, loci_number = R,loc_length) + feat_mutation(theta) + sumstat_trees() + sumstat_seg_sites()
stats <- simulate(model, seed = 15)

out = rep(0,R)
for(i in 1:R) {out[i] = length(stats$seg_sites[[i]]$position)}
N=min(max(out),n)

out = matrix(0,R,N)
for(i in 1:R) {
  curcolsums = colSums(stats$seg_sites[[i]]$snps)
  for(j in 1:N) {
    out[i,j]=sum(curcolsums==j)
  }
}
out = out[,-n]
sfs = out
```

TODO: compare

The numerator of Tajima's $D$ is $\hat{\theta}_{\pi}-\hat{\theta}_{\rm W}$ so the coefficient vector $\mathbf{c}$ is
$$
c_i = \frac{1}{\binom{n}{2}} i (n-i) - \frac{1}{\sum_{i=1}^{n-1} \frac{1}{i}}
$$
which is implemented below

```{r}
res = 1000
bc = res*(2*((1:(n-1))*( (n-1):1))/(n*(n-1)) - 1/sum(1/(1:(n-1))))
```

According to REF, the characteristic function is obtained as
$$
\phi(t) = \tilde{\psi}(\e^{\ih t})
$$
where
\begin{align*}
\tilde{\psi}(z) \eqdef \Exp [z^{\bc^\ast \bxi}] = \balpha^\ast \left( \bS + \lambda \Delta[\bR z^\bc] \right)^{-1} \bT \bone
\label{eq:phitildefun}
\end{align*}

The next snippet implements the $\phi$-function


```{r}
themean = mean(mean(ph_rew_obj)*bc) #the mean of the linear combination
bT = subintensity_matrix #bold T
bR = rew_mat #bold R
bS = bT - diag(rowSums(bR)) #bold S
bone = matrix(1,dim(bT)[1],1) #bold one = (1,1,...,1)^T
balpha = matrix(0,1,dim(bT)[1]);balpha[1]=1 #(1,0,...,0)
phi <- function(t) (exp(-1i*themean*t))*balpha%*%solve(bS+diag(c(bR%*%(exp(1i*t)^bc))) )%*%bT%*%bone
```




```{r}
appvals=ApproxCDF(phi,H = 1e5,eta=0.001,xlim=c(-1.5*res,2.5*res))

xvals=appvals[[1]]
yvals=appvals[[2]]

bc2 = (1/res)*bc
xvals2 = (1/res)*xvals
themean2 = (1/res)*themean
centered_sim2 = t(ph_counts)%*%bc2-c(themean2)
ecdfobj2 = ecdf(centered_sim2)

plot(xvals2,yvals,type="l",ylim=c(0,1))

lines(ecdfobj2,col="blue")
lines(xvals2,yvals,lwd=2)
```

```{r}
plot(xvals2,yvals,type="l",ylim=c(0,1),xlim=c(-0.5,0.5))

lines(ecdfobj2,col="blue")
lines(xvals2,yvals,lwd=2)
```
Next, we run the above code with

```{r}
n = 8
```


```{r,echo = FALSE}
#Define reward process
RMASS = RateMAndStateSpace(n)
m = dim(RMASS$RateM)[1] 

subintensity_matrix = RMASS$RateM[1:(m-1),1:(m-1)]

rew_mat = RMASS$StSpM[1:(m-1),1:(n-1)]

bT=RMASS$RateM[1:(dim(RMASS$RateM)[1]-1),1:(dim(RMASS$RateM)[1]-1)]
SPMAT=RMASS$StSpM[1:(dim(RMASS$StSpM)[1]-1),1:(dim(RMASS$StSpM)[2]-1)]
bone = matrix(1,dim(bT)[1],1) 
alpha = matrix(0,1,dim(bT)[1]);alpha[1]=1 
bR = SPMAT 
bS = bT - diag(rowSums(bR))

#Simulation
ph_obj=phase_type(subintensity_matrix)
ph_rew_obj=phase_type(subintensity_matrix, reward_mat = rew_mat)

ph_mv_sim_obj = sim_rew_phase_type(R,ph_rew_obj)
rew_dim = dim(ph_mv_sim_obj)[1]

ph_counts = matrix(0,rew_dim,dim(ph_mv_sim_obj)[2])
for(i in 1:rew_dim) {
  ph_counts[i,] = rpois(R,lambda*ph_mv_sim_obj[i,])
}

res = 1000
bc = res*(2*((1:(n-1))*( (n-1):1))/(n*(n-1)) - 1/sum(1/(1:(n-1))))

#compute characteristic function
themean = mean(mean(ph_rew_obj)*bc) #the mean of the linear combination
bT = subintensity_matrix #bold T
bR = rew_mat #bold R
bS = bT - diag(rowSums(bR)) #bold S
bone = matrix(1,dim(bT)[1],1) #bold one = (1,1,...,1)^T
balpha = matrix(0,1,dim(bT)[1]);balpha[1]=1 #(1,0,...,0)
phi <- function(t) (exp(-1i*themean*t))*balpha%*%solve(bS+diag(c(bR%*%(exp(1i*t)^bc))) )%*%bT%*%bone

#Invert numerically
appvals=ApproxCDF(phi,H = 1e5,eta=0.001,xlim=c(-3*res,3*res))

xvals=appvals[[1]]
yvals=appvals[[2]]

bc2 = (1/res)*bc
xvals2 = (1/res)*xvals
themean2 = (1/res)*themean
centered_sim2 = t(ph_counts)%*%bc2-c(themean2)
ecdfobj2 = ecdf(centered_sim2)

plot(xvals2,yvals,type="l",ylim=c(0,1))

lines(ecdfobj2,col="blue")
lines(xvals2,yvals,lwd=2)
```

